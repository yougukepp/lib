\documentclass[12pt,a4paper]{report}

\usepackage{xeCJK}
\usepackage{makeidx}
\usepackage{multirow}
\usepackage{color}
\usepackage{graphicx}
\usepackage[colorlinks,linkcolor=red]{hyperref}

\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{setspace}
\usepackage{palatino}

% Python语法高亮
\renewcommand{\lstlistlistingname}{Code Listings}
\renewcommand{\lstlistingname}{Code Listing}
\definecolor{gray}{gray}{0.5}
\definecolor{green}{rgb}{0,0.5,0}

\lstnewenvironment{python}[1][]{
    \lstset{
        language=python,
        basicstyle=\ttfamily\small\setstretch{1},
        stringstyle=\color{red},
        showstringspaces=false,
        alsoletter={1234567890},
        otherkeywords={\ , \}, \{},
        keywordstyle=\color{blue},
        emph={access,and,break,class,continue,def,del,elif ,else,%
            except,exec,finally,for,from,global,if,import,in,i s,%
        lambda,not,or,pass,print,raise,return,try,while},
        emphstyle=\color{orange}\bfseries,
        emph={[2]True, False, None, self},
        emphstyle=[2]\color{green},
        emph={[3]from, import, as},
        emphstyle=[3]\color{blue},
        upquote=true,
        morecomment=[s]{"""}{"""},
        commentstyle=\color{gray}\slshape,
        emph={[4]1, 2, 3, 4, 5, 6, 7, 8, 9, 0},
        emphstyle=[4]\color{blue},
        literate=*{:}{{\textcolor{blue}:}}{1}%
        {=}{{\textcolor{blue}=}}{1}%
        {-}{{\textcolor{blue}-}}{1}%
        {+}{{\textcolor{blue}+}}{1}%
        {*}{{\textcolor{blue}*}}{1}%
        {!}{{\textcolor{blue}!}}{1}%
        {(}{{\textcolor{blue}(}}{1}%
        {)}{{\textcolor{blue})}}{1}%
        {[}{{\textcolor{blue}[}}{1}%
        {]}{{\textcolor{blue}]}}{1}%
        {<}{{\textcolor{blue}<}}{1}%
        {>}{{\textcolor{blue}>}}{1},%
        framexleftmargin=1mm, framextopmargin=1mm, frame=shadowbox, rulesepcolor=\color{blue},#1
}}{}
% Python语法高亮结束


%楷体
\setCJKmainfont{AR PL UKai CN}

% 将日期变为中文格式
\renewcommand{\today}{\number\year 年 \number\month 月 \number\day 日}

\makeindex
\printindex
\setcounter{secnumdepth}{5}

\title{Python函数式编程指南}
\author{AstralWind(彭鹏 整理)}

\begin{document}
\maketitle
\tableofcontents
\newpage

\chapter{概述}
我的废话:网上找到了Python函数式编程的优秀博文一篇，为了避免遗失及熟悉xelatex排版，所以全文整理。

这大概算是Python最难啃的一块骨头吧。在我Python生涯的这一年里，我遇到了一些Pythoner，他们毫无例外地完全不会使用函数式编程（有些人喜欢称为Pythonic），比如，从来不会传递函数，不知道lambda是什么意思，知道列表展开但从来不知道用在哪里，对Python不提供经典for循环感到无所适从，言谈之中表现出对函数式风格的一种抗拒甚至厌恶。 

我尝试剖析这个问题，最终总结了这么两个原因：1、不想改变，认为现有的知识可以完成任务；2、对小众语言的歧视，Python目前在国内市场份额仍然很小很小，熟悉Python风格用处不大。 

然而我认为，学习使用一种截然不同的风格可以颠覆整个编程的思想。我会慢慢总结一个系列共4篇文字，篇幅都不大，轻松就能看完，希望对喜欢Python的人们有所帮助，因为我个人确实从中受益匪浅。 

还是那句老话，尊重作者的劳动，转载请注明原作者和原地址：）原文链接：\url{http://www.cnblogs.com/huxi/archive/2011/07/15/2107536.html}\href{http://www.cnblogs.com/huxi/archive/2011/07/15/2107536.html}{Python函数式编程指南：目录和参考}
\section{什么是函数式编程？} 
函数式编程使用一系列的函数解决问题。函数仅接受输入并产生输出，不包含任何能影响产生输出的内部状态。任何情况下，使用相同的参数调用函数始终能产生同样的结果。

在一个函数式的程序中，输入的数据“流过”一系列的函数，每一个函数根据它的输入产生输出。函数式风格避免编写有“边界效应”(side effects)的函数：修改内部状态，或者是其他无法反应在输出上的变化。完全没有边界效应的函数被称为“纯函数式的”(purely functional)。避免边界效应意味着不使用在程序运行时可变的数据结构，输出只依赖于输入。

可以认为函数式编程刚好站在了面向对象编程的对立面。对象通常包含内部状态（字段），和许多能修改这些状态的函数，程序则由不断修改状态构成；函数式编程则极力避免状态改动，并通过在函数间传递数据流进行工作。但这并不是说无法同时使用函数式编程和面向对象编程，事实上，复杂的系统一般会采用面向对象技术建模，但混合使用函数式风格还能让你额外享受函数式风格的优点。
\section{为什么使用函数式编程？} 
函数式的风格通常被认为有如下优点： 
\begin{enumerate}
\item[*]逻辑可证 
    
    这是一个学术上的优点：没有边界效应使得更容易从逻辑上证明程序是正确的（而不是通过测试）。

\item[*]模块化
    
    函数式编程推崇简单原则，一个函数只做一件事情，将大的功能拆分成尽可能小的模块。小的函数更易于阅读和检查错误。

\item[*]组件化

    小的函数更容易加以组合形成新的功能。

\item[*]易于调试
    
    细化的、定义清晰的函数使得调试更加简单。当程序不正常运行时，每一个函数都是检查数据是否正确的接口，能更快速地排除没有问题的代码，定位到出现问题的地方。

\item[*]易于测试
    
    不依赖于系统状态的函数无须在测试前构造测试桩，使得编写单元测试更加容易。

\item[*]更高的生产率
    
    函数式编程产生的代码比其他技术更少（往往是其他技术的一半左右），并且更容易阅读和维护。

\end{enumerate}
\section{如何辨认函数式风格？} 
支持函数式编程的语言通常具有如下特征，大量使用这些特征的代码即可被认为是函数式的： 
\begin{enumerate}
\item[*]函数是一等公民 
    
    函数能作为参数传递，或者是作为返回值返回。这个特性使得模板方法模式非常易于编写，这也促使了这个模式被更频繁地使用。以一个简单的集合排序为例，假设lst是一个数集，并拥有一个排序方法sort需要将如何确定顺序作为参数。如果函数不能作为参数，那么lst的sort方法只能接受普通对象作为参数。这样一来我们需要首先定义一个接口，然后定义一个实现该接口的类，最后将该类的一个实例传给sort方法，由sort调用这个实例的compare方法，就像这样：
\begin{python}[moreemph={[4]42},caption={},label=ex1]
#伪代码
interface Comparator {
    compare(o1, o2)
}
lst = list(range(5))
lst.sort(Comparator() {
    compare(o1, o2) {
        return o2 - o1 #逆序
    })
\end{python} 
    可见，我们定义了一个新的接口、新的类型（这里是一个匿名类），并new了一个新的对象只为了调用一个方法。如果这个方法可以直接作为参数传递会怎样呢？看起来应该像这样： 
    \begin{python}[moreemph={[4]42},caption={},label=ex1]
def compare(o1, o2):
    return o2 - o1 #逆序
lst = list(range(5))
lst.sort(compare)
    \end{python} 
    请注意，前一段代码已经使用了匿名类技巧从而省下了不少代码，但仍然不如直接传递函数简单、自然。 

\item[*]匿名函数(lambda) 
    
    lambda提供了快速编写简单函数的能力。对于偶尔为之的行为，lambda让你不再需要在编码时跳转到其他位置去编写函数。lambda表达式定义一个匿名的函数，如果这个函数仅在编码的位置使用到，你可以现场定义、直接使用： 
    \begin{python}[moreemph={[4]42},caption={},label=ex1]
lst.sort(lambda o1, o2: o1.compareTo(o2))
    \end{python} 
    
    相信从这个小小的例子你也能感受到强大的生产效率：） 

\item[*]封装控制结构的内置模板函数

    为了避开边界效应，函数式风格尽量避免使用变量，而仅仅为了控制流程而定义的循环变量和流程中产生的临时变量无疑是最需要避免的。假如我们需要对刚才的数集进行过滤得到所有的正数，使用指令式风格的代码应该像是这样： 
    \begin{python}[moreemph={[4]42},caption={},label=ex1]
lst2 = list()
for i in range(len(lst)): #模拟经典for循环
    if lst[i] > 0:
    lst2.append(lst[i])
    \end{python}
    这段代码把从创建新列表、循环、取出元素、判断、添加至新列表的整个流程完整的展示了出来，俨然把解释器当成了需要手把手指导的傻瓜。然而，“过滤”这个动作是很常见的，为什么解释器不能掌握过滤的流程，而我们只需要告诉它过滤规则呢？在Python里，过滤由一个名为filter的内置函数实现。有了这个函数，解释器就学会了如何“过滤”，而我们只需要把规则告诉它： 
    \begin{python}[moreemph={[4]42},caption={},label=ex1]
lst2 = filter(lambda n: n > 0, lst)
    \end{python}
    这个函数带来的好处不仅仅是少写了几行代码这么简单。封装控制结构后，代码中就只需要描述功能而不是做法，这样的代码更清晰，更可读。因为避开了控制结构的干扰，第二段代码显然能让你更容易了解它的意图。另外，因为避开了索引，使得代码中不太可能触发下标越界这种异常，除非你手动制造一个。函数式编程语言通常封装了数个类似“过滤”这样的常见动作作为模板函数。唯一的缺点是这些函数需要少量的学习成本，但这绝对不能掩盖使用它们带来的好处。
\item[*]闭包(closure)

    闭包是绑定了外部作用域的变量（但不是全局变量）的函数。大部分情况下外部作用域指的是外部函数。闭包包含了自身函数体和所需外部函数中的“变量名的引用”。引用变量名意味着绑定的是变量名，而不是变量实际指向的对象；如果给变量重新赋值，闭包中能访问到的将是新的值。闭包使函数更加灵活和强大。即使程序运行至离开外部函数，如果闭包仍然可见，则被绑定的变量仍然有效；每次运行至外部函数，都会重新创建闭包，绑定的变量是不同的，不需要担心在旧的闭包中绑定的变量会被新的值覆盖。回到刚才过滤数集的例子。假设过滤条件中的 0 这个边界值不再是固定的，而是由用户控制。如果没有闭包，那么代码必须修改为： 
    \newpage
    \begin{python}[moreemph={[4]42},caption={},label=ex1]
class greater_than_helper:
    def __init__(self, minval):
        self.minval = minval
    def is_greater_than(self, val):
        return val > self.minval
 
def my_filter(lst, minval):
    helper = greater_than_helper(minval)
    return filter(helper.is_greater_than, lst)
    \end{python}
    请注意我们现在已经为过滤功能编写了一个函数my\_filter。如你所见，我们需要在别的地方（此例中是类greater\_than\_helper）持有另一个操作数minval。如果支持闭包，因为闭包可以直接使用外部作用域的变量，我们就不再需要greater\_than\_helper了： 
    \begin{python}[moreemph={[4]42},caption={},label=ex1]
def my_filter(lst, minval):
    return filter(lambda n: n > minval, lst)
    \end{python}
    可见，闭包在不影响可读性的同时也省下了不少代码量。函数式编程语言都提供了对闭包的不同程度的支持。在Python 2.x中，闭包无法修改绑定变量的值，所有修改绑定变量的行为都被看成新建了一个同名的局部变量并将绑定变量隐藏。Python 3.x中新加入了一个关键字 nonlocal 以支持修改绑定变量。但不管支持程度如何，你始终可以访问（读取）绑定变量。 

\item[*]内置的不可变数据结构
    
    为了避开边界效应，不可变的数据结构是函数式编程中不可或缺的部分。不可变的数据结构保证数据的一致性，极大地降低了排查问题的难度。例如，Python中的元组(tuple)就是不可变的，所有对元组的操作都不能改变元组的内容，所有试图修改元组内容的操作都会产生一个异常。函数式编程语言一般会提供数据结构的两种版本（可变和不可变），并推荐使用不可变的版本。

\item[*]递归

    递归是另一种取代循环的方法。递归其实是函数式编程很常见的形式，经常可以在一些算法中见到。但之所以放到最后，是因为实际上我们一般很少用到递归。如果一个递归无法被编译器或解释器优化，很容易就会产生栈溢出；另一方面复杂的递归往往让人感觉迷惑，不如循环清晰，所以众多最佳实践均指出使用循环而非递归。 
\end{enumerate} 

\chapter{从函数开始}
\section{定义一个函数} 
如下定义了一个求和函数：
\begin{python}[moreemph={[4]42},caption={},label=ex1]
def add(x, y):
    return x + y
\end{python}

关于参数和返回值的语法细节可以参考其他文档，这里就略过了。使用lambda可以定义简单的单行匿名函数。lambda的语法是： 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
lambda args: expression
\end{python}

参数(args)的语法与普通函数一样，同时表达式(expression)的值就是匿名函数调用的返回值；而lambda表达式返回这个匿名函数。如果我们给匿名函数取个名字，就像这样： 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
lambda_add = lambda x, y: x + y
\end{python}

这与使用def定义的求和函数完全一样，可以使用lambda\_add作为函数名进行调用。然而，提供lambda的目的是为了编写偶尔为之的、简单的、可预见不会被修改的匿名函数。这种风格虽然看起来很酷，但并不是一个好主意，特别是当某一天需要对它进行扩充，再也无法用一个表达式写完时。如果一开始就需要给函数命名，应该始终使用def关键字。 
\section{使用函数赋值} 

事实上你已经见过了，上一节中我们将lambda表达式赋值给了add。同样，使用def定义的函数也可以赋值，相当于为函数取了一个别名，并且可以使用这个别名调用函数：
\begin{python}[moreemph={[4]42},caption={},label=ex1]
add_a_number_to_another_one_by_using_plus_operator = add
print add_a_number_to_another_one_by_using_plus_operator(1, 2)
\end{python}

既然函数可以被变量引用，那么将函数作为参数和返回值就是很寻常的做法了。

\section{闭包}
闭包是一类特殊的函数。如果一个函数定义在另一个函数的作用域中，并且函数中引用了外部函数的局部变量，那么这个函数就是一个闭包。下面的代码定义了一个闭包： 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
def f():
    n = 1
    def inner():
        print n
    inner()
    n = 'x'
    inner()
\end{python}

函数inner定义在f的作用域中，并且在inner中使用了f中的局部变量n，这就构成了一个闭包。闭包绑定了外部的变量，所以调用函数f的结果是打印1和'x'。这类似于普通的模块函数和模块中定义的全局变量的关系：修改外部变量能影响内部作用域中的值，而在内部作用域中定义同名变量则将遮蔽（隐藏）外部变量。

如果需要在函数中修改全局变量，可以使用关键字global修饰变量名。Python 2.x中没有关键字为在闭包中修改外部变量提供支持，在3.x中，关键字nonlocal可以做到这一点： 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
#Python 3.x supports `nonlocal'
def f():
    n = 1
    def inner():
    nonlocal n
    n = 'x'
print(n)
inner()
print(n)
\end{python}

调用这个函数的结果是打印1和'x'，如果你有一个Python 3.x的解释器，可以试着运行一下。

由于使用了函数体外定义的变量，看起来闭包似乎违反了函数式风格的规则即不依赖外部状态。但是由于闭包绑定的是外部函数的局部变量，而一旦离开外部函数作用域，这些局部变量将无法再从外部访问；另外闭包还有一个重要的特性，每次执行至闭包定义处时都会构造一个新的闭包，这个特性使得旧的闭包绑定的变量不会随第二次调用外部函数而更改。所以闭包实际上不会被外部状态影响，完全符合函数式风格的要求。（这里有一个特例，Python 3.x中，如果同一个作用域中定义了两个闭包，由于可以修改外部变量，他们可以相互影响。）

虽然闭包只有在作为参数和返回值时才能发挥它的真正威力，但闭包的支持仍然大大提升了生产率。
\section{作为参数}
如果你对OOP的模板方法模式很熟悉，相信你能很快速地学会将函数当作参数传递。两者大体是一致的，只是在这里，我们传递的是函数本身而不再是实现了某个接口的对象。我们先来给前面定义的求和函数add热热身： 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
print add('三角形的树', '北极')
\end{python}

与加法运算符不同，你一定很惊讶于答案是'三角函数'。\footnote{此处我经过实验结果时两个字符串的连接：“三角形的数北极”,怀疑原文有误。}这是一个内置的彩蛋...bazinga！言归正传。我们的客户有一个从0到4的列表： 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
lst = range(5) #[0, 1, 2, 3, 4]
\end{python}

虽然我们在上一小节里给了他一个加法器，但现在他仍然在为如何计算这个列表所有元素的和而苦恼。当然，对我们而言这个任务轻松极了：
\begin{python}[moreemph={[4]42},caption={},label=ex1]
amount = 0
for num in lst:
    amount = add(amount, num)
\end{python}

这是一段典型的指令式风格的代码，一点问题都没有，肯定可以得到正确的结果。现在，让我们试着用函数式的风格重构一下。

首先可以预见的是求和这个动作是非常常见的，如果我们把这个动作抽象成一个单独的函数，以后需要对另一个列表求和时，就不必再写一遍这个套路了： 
\newpage
\begin{python}[moreemph={[4]42},caption={},label=ex1]
def sum_(lst):
    amount = 0
    for num in lst:
        amount = add(amount, num)
        return amount 
    print sum_(lst)
\end{python}

还能继续。sum\_函数定义了这样一种流程： 
\begin{enumerate}
    \item 使用初始值与列表的第一个元素相加；
    \item 使用上一次相加的结果与列表的下一个元素相加；
    \item 重复第二步，直到列表中没有更多元素；
    \item 将最后一次相加的结果返回。
\end{enumerate}

如果现在需要求乘积，我们可以写出类似的流程--只需要把相加换成相乘就可以了： 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
def multiply(lst):
    product = 1
    for num in lst:
        product = product * num
    return product
\end{python}

除了初始值换成了1以及函数add换成了乘法运算符，其他的代码全部都是冗余的。我们为什么不把这个流程抽象出来，而将加法、乘法或者其他的函数作为参数传入呢？ 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
def reduce_(function, lst, initial):
    result = initial
    for num in lst:
    result = function(result, num)
    return result
     
print reduce_(add, lst, 0)
\end{python}

现在，想要算出乘积，可以这样做：
\begin{python}[moreemph={[4]42},caption={},label=ex1]
print reduce_(lambda x, y: x * y, lst, 1)
\end{python}

那么，如果想要利用reduce\_找出列表中的最大值，应该怎么做呢？请自行思考：）

虽然有模板方法这样的设计模式，但那样的复杂度往往使人们更情愿到处编写循环。将函数作为参数完全避开了模板方法的复杂度。

Python有一个内建函数reduce，完整实现并扩展了reduce\_的功能。本文稍后的部分包含了有用的内建函数的介绍。请注意我们的目的是没有循环，使用函数替代循环是函数式风格区别于指令式风格的最显而易见的特征。

*像Python这样构建于类C语言之上的函数式语言，由于语言本身提供了编写循环代码的能力，内置函数虽然提供函数式编程的接口，但一般在内部还是使用循环实现的。同样的，如果发现内建函数无法满足你的循环需求，不妨也封装它，并提供一个接口。
\section{作为返回值}
将函数返回通常需要与闭包一起使用（即返回一个闭包）才能发挥威力。我们先看一个函数的定义：
\begin{python}[moreemph={[4]42},caption={},label=ex1]
def map_(function, lst):
    result = []
    for item in lst:
        result.append(function(item))
    return result
\end{python}

函数map\_封装了最常见的一种迭代：对列表中的每个元素调用一个函数。map\_需要一个函数参数，并将每次调用的结果保存在一个列表中返回。这是指令式的做法，当你知道了列表解析(list comprehension)后，会有更好的实现。

这里我们先略过map\_的蹩脚实现而只关注它的功能。对于上一节中的lst，你可能发现最后求乘积结果始终是0，因为lst中包含了0。为了让结果看起来足够大，我们来使用map\_为lst中的每个元素加1：
\begin{python}[moreemph={[4]42},caption={},label=ex1]
lst = map_(lambda x: add(1, x), lst)
print reduce_(lambda x, y: x * y, lst, 1)
\end{python}

答案是120，这还远远不够大。再来：
\begin{python}[moreemph={[4]42},caption={},label=ex1]
lst = map_(lambda x: add(10, x), lst)
print reduce_(lambda x, y: x * y, lst, 1)
\end{python}

囧，事实上我真的没有想到答案会是360360，我发誓没有收周鸿祎任何好处。

现在回头看看我们写的两个lambda表达式：相似度超过90\%，绝对可以使用抄袭来形容。而问题不在于抄袭，在于多写了很多字符有木有？如果有一个函数，根据你指定的左操作数，能生成一个加法函数，用起来就像这样： 
\begin{python}[moreemph={[4]42},caption={},label=ex1]
\end{python}

\begin{python}[moreemph={[4]42},caption={},label=ex1]
\end{python}

\begin{python}[moreemph={[4]42},caption={},label=ex1]
\end{python}

\chapter{格式说明}

\begin{abstract}
这是摘要，留待扩展。
\end{abstract}

本文以下部分使用\LaTeXe{}最基本的配置完成文档的编写。 其中将介绍段落的划分、公式的使用、图形的插入\ldots 这篇文档中的内容将足以应付大多数应用。
\section{概述}
在编写文档时可以参考这部分的内容
\newpage

\section{表格}
\begin{table}[!hbp]
        \begin{tabular}{|c|c|c|c|c|}
                \hline
                \hline
                lable 1-1 & label 1-2 & label 1-3 & label 1 -4 & label 1-5 \\
                \hline
                label 2-1 & label 2-2 & label 3-3 & label 4-4 & label 5-5 \\
                \hline
                \multirow{2}{*}{Multi-Row} & \multicolumn{2}{|c|}{Multi-Column} & \multicolumn{2}{|c|}{\multirow{2}{*}{Multi-Row and Col}} \\
                \cline{2-3}
                & column-1 & column-2 & \multicolumn{2}{|c|}{}\\
                \hline
        \end{tabular}
        \caption{My first table}
\end{table} 
\newpage

\section{段落介绍}
\textcolor[rgb]{0.00, 0.50, 0.00}{带颜色的内容}
本章介绍段落的划分。\\
文档结束了。\\
列表项测试。
\begin{itemize}
        \item 第一大項,這裡是第一大項。
        \item 第二大項,這裡是第二大項。
                \begin{itemize}
                        \item 第一小項,這裡是第一小項。
                        \item 第二小項,這裡是第二小項。
                \end{itemize}
        \item 第三大項,這裡是第三大項。
        \item 第四大項,這裡是第四大項。
\end{itemize}
编号列表项测试。
\begin{enumerate}
        \item 第一大項,這裡是第一大項。
        \item 第二大項,這裡是第二大項。
                \begin{enumerate}
                        \item 第一小項,這裡是第一小項。
                        \item 第二小項,這裡是第二小項。
                \end{enumerate}
        \item 第三大項,這裡是第三大項。
        \item 第四大項,這裡是第四大項。
\end{enumerate}
描述列表项测试。
\begin{description}
        \item[第一大項] 這裡是第一大項。
        \item[第二大項] 這裡是第二大項。
                \begin{description}
                        \item[第一小項] 這裡是第一小項。
                        \item[第二小項] 這裡是第二小項。
                \end{description}
        \item[第三大項] 這裡是第三大項。
        \item[第四大項] 這裡是第四大項。
\end{description}
\newpage

\section{公式}

\begin{equation}
\epsilon > 0
\end{equation}

\begin{equation}
\lim_{n \to \infty}
\sum_{k=1}^n \frac{1}{k^2}
= \frac{\pi^2}{6}
\end{equation}

\newpage

\section{数学图像}
\setlength{\unitlength}{0.75mm}
\begin{picture}(60,40)
  \put(30,20){\vector(1,0){30}}
  \put(30,20){\vector(4,1){20}}
  \put(30,20){\vector(3,1){25}}
  \put(30,20){\vector(2,1){30}}
  \put(30,20){\vector(1,2){10}}
  \thicklines
  \put(30,20){\vector(-4,1){30}}
  \put(30,20){\vector(-1,4){5}}
  \thinlines
  \put(30,20){\vector(-1,-1){5}}
  \put(30,20){\vector(-1,-4){5}}
\end{picture}

\setlength{\unitlength}{1mm}
\newcommand{\wrt}[1]{\makebox(0,0)[c]{#1}}
\newcommand{\lline}[1]{\line(-1,0){#1}}
\newcommand{\rline}[1]{\line(1,0){#1}}
\newcommand{\uline}[1]{\line(0,1){#1}}
\newcommand{\dline}[1]{\line(0,-1){#1}}
\newcommand{\lvec}[1]{\vector(-1,0){#1}}
\newcommand{\rvec}[1]{\vector(1,0){#1}}
\newcommand{\uvec}[1]{\vector(0,1){#1}}
\newcommand{\dvec}[1]{\vector(0,-1){#1}}
\newsavebox{\condition}
\newsavebox{\process}
\newsavebox{\inputoutput}
\savebox{\process}(0,0){\thicklines
  \put(-10,-3){\framebox(20,6){}}
}
\savebox{\condition}(0,0){\thicklines
  \put(-10,0){\line(2,1){10}}
  \put(-10,0){\line(2,-1){10}}
  \put(10,0){\line(-2,1){10}}
  \put(10,0){\line(-2,-1){10}}
  }
\savebox{\inputoutput}(0,0){\thicklines
  \put(-10.5,-3){\rline{18}}
  \put(-10.5,-3){\line(1,2){3}}
  \put(10.5,3){\lline{18}}
  \put(10.5,3){\line(-1,-2){3}}
}
\begin{center}
\setlength{\unitlength}{0.75mm}
\begin{picture}(45,73)(20,-73)
        \thicklines
        \put(40,-19){\usebox{\process}}
        \put(40,3){\wrt{开始}}
        \put(40,0){\dvec{5}}
\put(40,-8){\usebox{\inputoutput}} \put(40,-8){\wrt{输入$m,\,n$}}
\put(40,-11){\dvec{5}} \put(40,-19){\usebox{\process}}
\put(40,-19){\wrt{$i=1$}} \put(40,-22){\dvec{8}}
\put(40,-33){\usebox{\process}} \put(40,-33){\wrt{$a=m\times i$}}
\put(40,-36){\dvec{5}} \put(40,-46){\usebox{\condition}}
\put(40,-46){\wrt{$n$整除$a$?}} \put(40,-51){\dvec{5}}
\put(41,-53){\makebox(0,0)[l]{是}}
\put(40,-59){\usebox{\inputoutput}} \put(40,-59){\wrt{输出$a,\,i$}}
\put(40,-62){\dvec{5}}
\put(40,-70){\oval(15,6)}\put(40,-70){\wrt{结束}}
\put(30,-46){\line(-1,0){15}} \put(28,-45){\makebox(0,0)[b]{否}}
\put(15,-46){\uvec{10}} \put(15,-33){\usebox{\process}}
\put(15,-33){\wrt{$i=i+1$}} \put(15,-30){\line(0,1){5}}
\put(15,-25){\rvec{25}}
\end{picture}
\end{center}

\begin{figure}[!hbp]
\setlength{\unitlength}{1mm}
\begin{picture}(136, 100)
        %绘制坐标线
        \linethickness{0.01mm}
        \put(0, 0){\framebox(136, 100){}}
        \linethickness{0.01mm}
        \multiput(0,0)(13.6,0){10}{\line(0,1){100}}
        \multiput(0,0)(0, 10){10}{\line(1, 0){136}}
        \linethickness{0.1mm}
        \put(10, 94){\framebox(20, 6){源文件}}
        \put(10, 84){\framebox(20, 6){源解析}}
        \put(116, 68){\framebox(20, 6){控制文件}}
        \put(90, 62){\framebox(20, 18){控制解析}}
        \put(35, 0){\framebox(20, 6){视频文件}}
        \put(30, 10){\framebox(60, 6){输出控制}}
        \put(65, 0){\framebox(20, 6){显示器}}
        \put(30, 40){\framebox(40, 30){\LARGE引擎核心}}
        \put(10, 10){\framebox(100, 80){}}
        \put(40, 65){\makebox(40,30){\huge Qe引擎}}

        \thinlines
        \put(20, 94){\vector(0, -1){4}}
        \put(20, 84){\line(0, -1){30}}
        \put(20, 54){\vector(1, 0){10}}
        \put(116, 71){\vector(-1, 0){6}}
        \put(80, 54){\line(0, 1){17}}
        \put(80, 71){\line(1, 0){10}}
        \put(80, 54){\vector(-1, 0){10}}
        \put(60, 30){\vector(0, -1){14}}
        \put(60, 30){\line(-1, 0){10}}
        \put(50, 30){\line(0, 1){10}}
\end{picture}
\caption{子系统交互\label{子系统交互}}
\end{figure}
\newpage

\section{整段English试试}
Hello, I'm brother peng!
\newpage

\section{脚注}
测试脚注\footnote{我是脚注.}


\section{边注}
测试边注\marginpar{我是边注}

\end{document}

